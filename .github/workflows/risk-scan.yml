name: RISK scan (incremental users_tzvira -> risk_reviews)

on:
  # אוטומטי: כל 10 דקות
  schedule:
    - cron: "*/10 * * * *"
  # ידני
  workflow_dispatch:
    inputs:
      limit:
        description: "כמה שורות users_tzvira לסרוק בכל ריצה (ברירת מחדל 200)"
        required: false
        default: "200"
        type: string
      dry_run:
        description: "true = לא מכניס ל-risk_reviews ולא מעדכן watermark"
        required: false
        default: "false"
        type: string

permissions:
  contents: read

concurrency:
  group: risk-scan-${{ github.ref }}
  cancel-in-progress: true

jobs:
  scan:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      SUPABASE_URL: ${{ secrets.supabase_url }}
      SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      LIMIT: ${{ github.event.inputs.limit || '200' }}
      DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Ensure jq is available
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
          jq --version

      - name: Validate required env
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${SUPABASE_URL:-}" ]]; then
            echo "❌ Missing secret: supabase_url"; exit 1
          fi
          if [[ -z "${SUPABASE_KEY:-}" ]]; then
            echo "❌ Missing secret: SUPABASE_SERVICE_ROLE_KEY"; exit 1
          fi

      - name: Get watermark (risk_scan_state)
        id: state
        shell: bash
        run: |
          set -euo pipefail
          ENDPOINT="${SUPABASE_URL%/}/rest/v1/risk_scan_state"
          echo "GET $ENDPOINT (id,last_time_key)"

          # IMPORTANT:
          # last_time_key הוא BIGINT (לפי השגיאה שקיבלת). לכן:
          # - ברירת מחדל: 0
          # - נשמור ועדכן מספר (לא מחרוזת)

          if ! curl -sS --fail-with-body \
            -H "apikey: ${SUPABASE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_KEY}" \
            -H "Accept: application/json" \
            -G "$ENDPOINT" \
            --data-urlencode "select=id,last_time_key" \
            --data-urlencode "order=id.asc" \
            --data-urlencode "limit=1" \
            > state.json
          then
            echo "WARN: failed to fetch risk_scan_state; using defaults"
            echo "[]" > state.json
          fi

          # state.json צפוי להיות מערך; אם זה לא מערך (למשל אובייקט שגיאה) – ניפול לברירות מחדל
          if jq -e 'type=="array"' state.json >/dev/null 2>&1; then
            ID="$(jq -r 'if length>0 and .[0].id!=null then .[0].id else 1 end' state.json)"
            LAST="$(jq -r 'if length>0 and .[0].last_time_key!=null then .[0].last_time_key else 0 end' state.json)"
          else
            ID="1"
            LAST="0"
          fi

          # הגנה: LAST חייב להיות מספר
          if ! [[ "$LAST" =~ ^[0-9]+$ ]]; then
            echo "WARN: last_time_key is not numeric ($LAST); forcing 0"
            LAST="0"
          fi

          echo "state_id=$ID" >> "$GITHUB_OUTPUT"
          echo "last_time_key=$LAST" >> "$GITHUB_OUTPUT"

      - name: Fetch risk_phrases
        shell: bash
        run: |
          set -euo pipefail
          ENDPOINT="${SUPABASE_URL%/}/rest/v1/risk_phrases"
          echo "GET $ENDPOINT"

          # חשוב: אל תשבור ריצה אם risk_phrases ריק/לא נגיש – נמשיך עם []
          if ! curl -sS --fail-with-body \
            -H "apikey: ${SUPABASE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_KEY}" \
            -H "Accept: application/json" \
            -G "${ENDPOINT}" \
            --data-urlencode "select=*" \
            --data-urlencode "order=id.asc" \
            > phrases.json
          then
            echo "WARN: failed to fetch risk_phrases; using []"
            echo "[]" > phrases.json
          fi

          if ! jq -e . phrases.json >/dev/null 2>&1; then
            echo "WARN: invalid JSON for phrases; using []"
            echo "[]" > phrases.json
          fi

      - name: Fetch users_tzvira incrementally
        shell: bash
        run: |
          set -euo pipefail
          ENDPOINT="${SUPABASE_URL%/}/rest/v1/users_tzvira"
          LAST="${{ steps.state.outputs.last_time_key }}"
          echo "GET $ENDPOINT (time > $LAST), limit=$LIMIT"

          if ! curl -sS --fail-with-body \
            -H "apikey: ${SUPABASE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_KEY}" \
            -H "Accept: application/json" \
            -G "$ENDPOINT" \
            --data-urlencode "select=time,phone,last_talk_tzvira" \
            --data-urlencode "time=gt.${LAST}" \
            --data-urlencode "order=time.asc" \
            --data-urlencode "limit=${LIMIT}" \
            > talks.json
          then
            echo "WARN: failed to fetch users_tzvira; using []"
            echo "[]" > talks.json
          fi

          if ! jq -e . talks.json >/dev/null 2>&1; then
            echo "WARN: invalid JSON for talks; using []"
            echo "[]" > talks.json
          fi

      - name: Build risk payload (Node)
        id: build_payload
        shell: bash
        run: |
          set -euo pipefail

          node scripts/risk_scan_build_payload.mjs \
            --talks talks.json \
            --phrases phrases.json \
            --out payload.json \
            --out-max-time max_time.txt \
            --context 80

          HITS="$(jq 'if type=="array" then length else 0 end' payload.json 2>/dev/null || echo 0)"

          # IMPORTANT:
          # watermark חייב להיות BIGINT, אז נשתמש במקסימום של talks[].time (מספר),
          # ולא במחרוזת "max_time.txt" שה-Node מייצר.
          MAX_KEY="$(jq -r 'if type=="array" and length>0 then ([.[].time] | max) else empty end' talks.json 2>/dev/null || true)"

          if [[ -z "${MAX_KEY:-}" ]]; then
            MAX_KEY="0"
          fi
          if ! [[ "$MAX_KEY" =~ ^[0-9]+$ ]]; then
            echo "WARN: computed MAX_KEY is not numeric ($MAX_KEY); forcing 0"
            MAX_KEY="0"
          fi

          echo "hits=$HITS" >> "$GITHUB_OUTPUT"
          echo "max_time_key=$MAX_KEY" >> "$GITHUB_OUTPUT"

          # לוג קצר (מועיל בדיבוג)
          TALKS="$(jq 'if type=="array" then length else 0 end' talks.json 2>/dev/null || echo 0)"
          PHRASES="$(jq 'if type=="array" then length else 0 end' phrases.json 2>/dev/null || echo 0)"
          echo "talks=$TALKS phrases=$PHRASES hits=$HITS maxKey=$MAX_KEY"

      - name: Validate payload has pattern_key (fail fast)
        if: ${{ steps.build_payload.outputs.hits != '0' }}
        shell: bash
        run: |
          set -euo pipefail
          # אם יש רשומה בלי pattern_key – זה יפיל את ה-INSERT עם NOT NULL
          MISSING="$(jq '[.[] | select((.pattern_key // "")=="")] | length' payload.json)"
          if [[ "$MISSING" != "0" ]]; then
            echo "❌ payload.json contains rows with missing pattern_key: $MISSING"
            echo "First 5 offending rows:"
            jq -c '.[] | select((.pattern_key // "")=="")' payload.json | head -n 5 || true
            exit 1
          fi

      - name: Insert risk_reviews (ignore duplicates; show PostgREST body on 4xx/5xx)
        if: ${{ steps.build_payload.outputs.hits != '0' && env.DRY_RUN != 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          ENDPOINT="${SUPABASE_URL%/}/rest/v1/risk_reviews"
          echo "POST $ENDPOINT (Prefer: ignore-duplicates)"

          RESP_HEADERS="$(mktemp)"
          RESP_BODY="$(mktemp)"
          HTTP_CODE="$(
            curl -sS \
              -D "$RESP_HEADERS" \
              -o "$RESP_BODY" \
              -w "%{http_code}" \
              -H "apikey: ${SUPABASE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_KEY}" \
              -H "Content-Type: application/json" \
              -H "Prefer: resolution=ignore-duplicates" \
              -d @payload.json \
              "$ENDPOINT" || true
          )"

          if [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "Insert OK (HTTP $HTTP_CODE)"
          else
            echo "❌ Insert failed (HTTP $HTTP_CODE). Response headers:"
            sed -n '1,120p' "$RESP_HEADERS" || true
            echo ""
            echo "❌ Insert failed. Response body:"
            cat "$RESP_BODY" || true
            exit 1
          fi

      - name: Update watermark (risk_scan_state.last_time_key) - show body on 4xx/5xx
        if: ${{ env.DRY_RUN != 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          MAX_KEY="${{ steps.build_payload.outputs.max_time_key }}"
          if [[ -z "${MAX_KEY:-}" || "${MAX_KEY}" == "0" ]]; then
            echo "No max_time_key (no talks in batch); skipping watermark update."
            exit 0
          fi

          ID="${{ steps.state.outputs.state_id }}"
          ENDPOINT="${SUPABASE_URL%/}/rest/v1/risk_scan_state"
          echo "UPSERT $ENDPOINT id=$ID last_time_key=$MAX_KEY"

          BODY_FILE="$(mktemp)"
          printf '[{"id": %s, "last_time_key": %s}]' "$ID" "$MAX_KEY" > "$BODY_FILE"

          RESP_HEADERS="$(mktemp)"
          RESP_BODY="$(mktemp)"
          HTTP_CODE="$(
            curl -sS \
              -D "$RESP_HEADERS" \
              -o "$RESP_BODY" \
              -w "%{http_code}" \
              -H "apikey: ${SUPABASE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_KEY}" \
              -H "Content-Type: application/json" \
              -H "Prefer: resolution=merge-duplicates" \
              -d @"$BODY_FILE" \
              "$ENDPOINT" || true
          )"

          if [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "Watermark upsert OK (HTTP $HTTP_CODE)"
          else
            echo "❌ Watermark upsert failed (HTTP $HTTP_CODE). Response body:"
            cat "$RESP_BODY" || true
            exit 1
          fi

      - name: Step summary (visible in run Summary tab)
        if: always()
        shell: bash
        run: |
          TALKS="$(jq 'if type=="array" then length else 0 end' talks.json 2>/dev/null || echo 0)"
          PHRASES="$(jq 'if type=="array" then length else 0 end' phrases.json 2>/dev/null || echo 0)"
          HITS="$(jq 'if type=="array" then length else 0 end' payload.json 2>/dev/null || echo 0)"
          LAST="${{ steps.state.outputs.last_time_key }}"
          MAXK="${{ steps.build_payload.outputs.max_time_key }}"
          {
            echo "## RISK scan – Summary"
            echo ""
            echo "- dry_run: ${DRY_RUN}"
            echo "- limit: ${LIMIT}"
            echo "- talks fetched: ${TALKS}"
            echo "- phrases fetched: ${PHRASES}"
            echo "- hits built: ${HITS}"
            echo "- last_time_key (before): ${LAST}"
            echo "- max_time_key (batch): ${MAXK}"
          } >> "$GITHUB_STEP_SUMMARY"
